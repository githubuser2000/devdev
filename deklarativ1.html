<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Funktionale Funktionsverwendungen</title>
</head>
<body>

<h1>Besondere Funktionsverwendungen deklarativ-funktionaler Sprachen</h1>

<h2>Haskell – Funktionen als algebraische Objekte</h2>

<h3>Funktionen mit Gesetzen</h3>
<p>
Funktionen unterliegen algebraischen Strukturen wie Functor, Monad oder Category.
Man beschreibt Gesetzssysteme statt Abläufe.
</p>

<h3>Funktionen über Typkonstruktoren</h3>
<p>
Funktionen arbeiten über ganze Typfamilien und erhalten deren Struktur.
</p>

<h3>Komposition statt Kontrolle</h3>
<p>
Kontrollfluss entsteht aus Funktionskomposition statt aus Befehlsfolgen.
</p>

<h2>Idris 2 – Funktionen als Beweise</h2>

<h3>Abhängige Typen</h3>
<p>
Typen enthalten Werte. Korrektheit wird beim Kompilieren erzwungen.
</p>

<h3>Programme als logische Aussagen</h3>
<p>
Programme sind gleichzeitig mathematische Beweise.
</p>

<h3>Totalität</h3>
<p>
Alle Fälle müssen abgedeckt sein, Terminierung ist garantiert.
</p>

<h2>Lisp – Funktionen als formbare Syntax</h2>

<h3>Code als Daten</h3>
<p>
Programme sind Datenstrukturen und können transformiert werden.
</p>

<h3>Makros</h3>
<p>
Makros verändern die Sprache selbst durch AST-Transformation.
</p>

<h3>Sprachen als Ergebnis von Funktionen</h3>
<p>
DSLs entstehen funktional.
</p>

<h2>Scala – Funktionen als Integrationswerkzeug</h2>

<h3>Algebraische Architektur</h3>
<p>
Daten und Verhalten werden algebraisch getrennt.
</p>

<h3>Kontextabhängige Funktionen</h3>
<p>
Funktionen verlangen Fähigkeiten über implizite Kontexte.
</p>

<h3>Effekte als Werte</h3>
<p>
Nebenwirkungen werden beschrieben, nicht direkt ausgeführt.
</p>

<h2>Gemeinsamer Kern</h2>
<p>
Funktionen beschreiben Wahrheit statt Ablauf.
</p>

</body>
</html>
